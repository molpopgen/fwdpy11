.. _ts_data_types:

Data structures related to tree sequences
======================================================================

Low-level data types
----------------------------------------------------------

* :class:`fwdpy11.ts.Node` defines nodes
* :class:`fwdpy11.ts.Edge` defines edges
* :class:`fwdpy11.ts.MutationRecord` defines mutations locations on trees and in :class:`fwdpy11.Population` objects.

* :class:`fwdpy11.ts.NodeTable` represents a node table
* :class:`fwdpy11.ts.EdgeTable` represents an edge table
* :class:`fwdpy11.ts.MutationTable` represents a mutation table

Table collections
----------------------------------------------------------

The above data types are encapsulated into the Python class :class:`fwdpy11.ts.TableCollection`.  Instances of this
class are data fields of populations, via :attr:`fwdpy11.Population.tables`.

Representing trees
----------------------------------------------------------

An edge table and a node table contain all the data required to generate what we may call "marginal trees", which are the trees
corresponding to genomic intervals :math:`[left, right)`. In fwdpy11, :class:`fwdpy11.ts.MarginalTree` represents such
trees.  These marginal tree objects are generated by instances of :class:`fwdpy11.ts.TreeVisitor`, which advances over
trees from left to right along a genome.

You'll see these types in action in the next section, :ref:`ts`.  Here, I want
to describe the structure of the marginal trees and get some terminology out of the way.  I will use Jerome Kelleher's
msprime_ package to illustrate the concepts.  fwdpy11 uses the same basic data model, and it is more convenient to use trees
generated via a coalescent simulation that to run forward simulations.  Plus, we can use the great "draw" methods from
msprime_!

.. note:: 

    Do not mistake the msprime_ operations used below for the operations needed in fwdpy11.  They differ in some
    important ways.  Namely, the msprime_ API is currently richer and the fwdpy11 API is currently more low-level.
    The main goal here is to define terms and visualize them.

We are going to look at a single tree, but the concepts apply to any of the trees generated by a simulation with nonzero
recombination rates.  First, let's get a tree sequence:

.. ipython:: python

    import msprime

    # The following makes use of the Kirk Lohmueller seed.
    ts = msprime.simulate(10, random_seed=101*405*10*110)
    print(ts.first().draw(format="unicode"))


The above three correponds to a sample size of 10 haplotypes.  The tree shows the node labels.  The nodes labelled 0
through 9 correspond to the present time point--these are "alive nodes" or the "current generation" if we are thinking
about a forward simulation.  Further, we can describe the branches leading to these sample nodes as the "tips" or
"leaves" of a tree.  

"Leaves" of a tree
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

One thing that we often want to know is "how many samples descend from node `i`?" To do that, we
may look at the leaf counts attribute of a marginal tree:

.. ipython:: python

    # Let's store our 
    # tree in a variable now
    t = ts.first()

    def get_leaf_counts(tree, i):
        return len([j for j in tree.leaves(i)])

    # Map node ids to their leaf counts using a dict
    lcmap = {i:"{}".format(get_leaf_counts(t,i)) for i in range(len(ts.tables.nodes))}
    print(t.draw(format="unicode",node_labels=lcmap))

Children and siblings
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Let's take another look at our tree, labelled with node ids:

.. ipython:: python

    print(t.draw(format="unicode"))


Let's ponder node 13 for a moment.  It has two immediate descendants, nodes 4 and 11.  We may consider
these the left and right children, respectively, of node 13.  Likewise, we may label node 11 as the right sibling of
node 4, and node 4 as the left sibling of node 11.  Let's see what we mean.  First, we'll plot the left/right children
of each node:

.. ipython:: python

    def get_children(tree, i):
        lc = tree.left_child(i)
        rc = tree.right_child(i)
        if lc == msprime.NULL_NODE and rc == msprime.NULL_NODE:
            return "{}->NULL".format(i)
        return "{}->".format(i) + str((lc, rc))

    cmap = {i:get_children(t,i) for i in range(len(ts.tables.nodes))}
    print(t.draw(format="unicode", node_labels=cmap))


Now, let's look at the sibling relationships:

.. ipython:: python

    def get_sibs(tree, i):
        ls = tree.left_sib(i)
        rs = tree.right_sib(i)
        if ls == msprime.NULL_NODE and rs == msprime.NULL_NODE:
            return "{}->NULL".format(i)
        return "{}->".format(i) + str((ls, rs))

    smap = {i:get_sibs(t,i) for i in range(len(ts.tables.nodes))}
    print(t.draw(format="unicode", node_labels=smap))

Multiply-linked lists
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Under the hood, the data structures representing marginal trees consist of several arrays
represening a multiply-linked list allowing traversal up/down/left/right along a marginal tree.
By convention, the value -1 is taken as a NULL value, signifying that there are no more nodes in
"that" direction along the tree.  

We can look directly at what theses arrays look like in our tree:

.. ipython:: python

    nnodes = len(ts.tables.nodes)
    # First, let's write down our node ids:
    print([i for i in range(nnodes)])
    # Now, get the parents of each node, moving "up" the tree
    print([t.parent(i) for i in range(nnodes)])
    # The left child list allows moving "down left" along a tree
    print([t.left_child(i) for i in range(nnodes)])
    # The right child list allows moving "down right" along a tree
    print([t.right_child(i) for i in range(nnodes)])
    # The left sib list allows moving "left" along a tree
    print([t.left_sib(i) for i in range(nnodes)])
    # The right sib list allows moving "right" along a tree
    print([t.right_sib(i) for i in range(nnodes)])

Given the above lists, you may start at any valid node id (*e.g.* a value not equal to -1 in the first array),
and then "walk" in any direction you choose along the tree until you hit a value of -1, meaning that you cannot proceed 
any further.

.. note::

    The trees generated by `msprime.simulate` are bifurcating, which is a consequence of simulating from the Kingman
    coalescent.  In forward-time simulations, it is not uncommon to have more than two descendants of a node.  When that
    happens, left_child and right_child refer to the left-most and right-most children, respectively. Thus, to "walk"
    along the descendants of a node, you proceed to left_child, and then march along right_sib until a value of -1 is
    seen.  This "walking" method is the same as what you would do for a bifurcating tree, but I want to point out that 
    counting the number of immediate descendants of a node requires counting the number of steps that the walk requires,
    and that it may be longer than two steps.

The last five arrays show above correspond to the following attributes of :class:`fwdpy11.ts.MarginalTree`:

* :attr:`fwdpy11.ts.MarginalTree.parents`
* :attr:`fwdpy11.ts.MarginalTree.left_child`
* :attr:`fwdpy11.ts.MarginalTree.right_child`
* :attr:`fwdpy11.ts.MarginalTree.left_sib`
* :attr:`fwdpy11.ts.MarginalTree.right_sib`

The key to efficiency is how these linked lists are updated as you move from tree :math:`i` to tree :math:`i+1`.  Given
an approprate set of indexes, these lists are only updated at the positions that differ between the two trees.  In
practice, adjacent trees are highly-correlated, meaning that very few values need updating. The
construction of these indexes is described immediatlely above the description of "Algorithm T" in the Kelleher et al. (2016) paper describing msprime_.

.. _msprime: http://msprime.readthedocs.io
The building of those indexes is a key determinant of performance for algorithms on tree sequences.  Fortunately, you
don't need to worry about that, as that machinery is hidden in the internals of fwdpp (and msprime).
